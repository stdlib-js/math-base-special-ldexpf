{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The following copyright and license were part of the original implementation available as part of [FreeBSD]{@link https://svnweb.freebsd.org/base/release/12.2.0/lib/msun/src/s_scalbnf.c?view=markup}. The implementation follows the original, but has been modified for JavaScript.\n*\n* ```text\n* Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n*\n* Developed at SunPro, a Sun Microsystems, Inc. business.\n* Permission to use, copy, modify, and distribute this\n* software is freely granted, provided that this notice\n* is preserved.\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nimport PINF from '@stdlib/constants-float32-pinf';\nimport copysignf from '@stdlib/math-base-special-copysignf';\nimport toWord from '@stdlib/number-float32-base-to-word';\nimport fromWord from '@stdlib/number-float32-base-from-word';\nimport float64ToFloat32 from '@stdlib/number-float64-base-to-float32';\nimport FLOAT32_EXPONENT_MASK from '@stdlib/constants-float32-exponent-mask';\nimport FLOAT32_PRECISION from '@stdlib/constants-float32-precision';\nimport FLOAT32_ABS_MASK from '@stdlib/constants-float32-abs-mask';\n\n\n// VARIABLES //\n\nvar TWO25 = 33554432.0; // 0x4c000000\nvar TWOM25 = 2.9802322387695312e-8; // 0x33000000\nvar FLOAT32_SIGNIFICAND_MASK_WITH_SIGN = 0x807fffff; // 1 00000000 11111111111111111111111\nvar ALL_ONES = 0xff; // 0xff = 255 => 11111111\n\n\n// MAIN //\n\n/**\n* Multiplies a single-precision floating-point number by an integer power of two.\n*\n* @param {number} frac - fraction\n* @param {integer} exp - exponent\n* @returns {number} single-precision floating-point number\n*\n* @example\n* var x = ldexpf( 0.5, 3 ); // => 0.5 * 2^3 = 0.5 * 8\n* // returns 4.0\n*\n* @example\n* var x = ldexpf( 4.0, -2 ); // => 4 * 2^(-2) = 4 * (1/4)\n* // returns 1.0\n*\n* @example\n* var x = ldexpf( 0.0, 20 );\n* // returns 0.0\n*\n* @example\n* var x = ldexpf( -0.0, 39 );\n* // returns -0.0\n*\n* @example\n* var x = ldexpf( NaN, -101 );\n* // returns NaN\n*\n* @example\n* var x = ldexpf( Infinity, 11 );\n* // returns Infinity\n*\n* @example\n* var x = ldexpf( -Infinity, -118 );\n* // returns -Infinity\n*/\nfunction ldexpf( frac, exp ) {\n\tvar ix;\n\tvar k;\n\n\tfrac = float64ToFloat32( frac );\n\tix = toWord( frac );\n\n\t// Extract exponent:\n\tk = ( ix & FLOAT32_EXPONENT_MASK ) >> ( FLOAT32_PRECISION - 1 );\n\n\t// 0 or subnormal frac:\n\tif ( k === 0 ) {\n\t\tif ( ( ix & FLOAT32_ABS_MASK ) === 0 ) {\n\t\t\t// +-0:\n\t\t\treturn frac;\n\t\t}\n\t\tfrac = float64ToFloat32( frac * TWO25 );\n\t\tix = toWord( frac );\n\t\tk = ( ( ix & FLOAT32_EXPONENT_MASK ) >> ( FLOAT32_PRECISION - 1 ) ) - 25;\n\t\tif ( exp < -50000 ) {\n\t\t\t// Underflow:\n\t\t\treturn 0.0;\n\t\t}\n\t}\n\n\t// NaN or Inf:\n\tif ( k === ALL_ONES ) {\n\t\treturn float64ToFloat32( frac + frac );\n\t}\n\tk = ( k + exp ) | 0;\n\tif ( k > ALL_ONES - 1 ) {\n\t\t// Overflow:\n\t\treturn copysignf( PINF, frac );\n\t}\n\tif ( k > 0 ) {\n\t\t// Normal result:\n\t\tfrac = fromWord( ( ix & FLOAT32_SIGNIFICAND_MASK_WITH_SIGN ) | ( k << ( FLOAT32_PRECISION - 1 ) ) );\n\t\treturn frac;\n\t}\n\tif ( k <= -25 ) {\n\t\tif ( exp > 50000 ) {\n\t\t\t// In case of integer overflow in n + k:\n\t\t\treturn copysignf( PINF, frac );\n\t\t}\n\n\t\t// Underflow:\n\t\treturn copysignf( 0.0, frac );\n\t}\n\n\t// Subnormal result:\n\tk += 25;\n\tfrac = fromWord( ( ix & FLOAT32_SIGNIFICAND_MASK_WITH_SIGN ) | ( k << ( FLOAT32_PRECISION - 1 ) ) );\n\treturn float64ToFloat32( frac * TWOM25 );\n}\n\n\n// EXPORTS //\n\nexport default ldexpf;\n"],"names":["FLOAT32_SIGNIFICAND_MASK_WITH_SIGN","ldexpf","frac","exp","ix","k","float64ToFloat32","toWord","FLOAT32_EXPONENT_MASK","FLOAT32_PRECISION","FLOAT32_ABS_MASK","ALL_ONES","copysignf","PINF","fromWord"],"mappings":";;mzBAgDA,IAEIA,EAAqC,WAyCzC,SAASC,EAAQC,EAAMC,GACtB,IAAIC,EACAC,EASJ,GAPAH,EAAOI,EAAkBJ,GAOd,KAHXG,IAHAD,EAAKG,EAAQL,IAGFM,IAA6BC,EAAoB,GAG7C,CACd,GAAmC,IAA5BL,EAAKM,GAEX,OAAOR,EAKR,GAHAA,EAAOI,EA3DG,SA2DeJ,GAEzBG,KADAD,EAAKG,EAAQL,IACAM,IAA6BC,EAAoB,GAAQ,GACjEN,GAAO,IAEX,OAAO,CAER,CAGD,OAlEc,MAkETE,EACGC,EAAkBJ,EAAOA,IAEjCG,EAAMA,EAAIF,EAAQ,GACTQ,IAEDC,EAAWC,EAAMX,GAEpBG,EAAI,EAERH,EAAOY,EAAYV,EAAKJ,EAAyCK,GAAOI,EAAoB,GAGxFJ,IAAM,GAGFO,EAFHT,EAAM,IAEQU,EAID,EAJOX,IAS1BA,EAAOY,EAAYV,EAAKJ,GADxBK,GAAK,KACmEI,EAAoB,GACrFH,EA9FK,sBA8FaJ,GAC1B"}